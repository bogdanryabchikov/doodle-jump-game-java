import javafx.animation.AnimationTimer;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Alert;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.*;
import javafx.scene.paint.*;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;
import javafx.stage.Stage;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;

public class DoodleJump extends Application {
    
    // Константы - увеличены на 10%
    public static final int WIDTH = 440;
    public static final int HEIGHT = 660;
    public static final int FPS = 60;
    public static final double GRAVITY = 0.4;
    public static final double JUMP_FORCE = 10;
    public static final int PLATFORM_WIDTH = 70;
    public static final int PLATFORM_HEIGHT = 20;
    public static final int PLAYER_WIDTH = 45;
    public static final int PLAYER_HEIGHT = 60;
    public static final int SCROLL_THRESHOLD = 220;
    public static final int MIN_HEIGHT_FOR_SCORE = 55;
    public static final int MIN_PLATFORM_DISTANCE = 80;
    
    // Цвета
    public static final Color WHITE = Color.WHITE;
    public static final Color BLACK = Color.BLACK;
    public static final Color YELLOW = Color.YELLOW;
    public static final Color ORANGE = Color.ORANGE;
    public static final Color RED = Color.rgb(255, 50, 50);
    public static final Color GREEN = Color.rgb(50, 255, 50);
    public static final Color BLUE = Color.rgb(50, 100, 255);
    public static final Color PURPLE = Color.rgb(180, 70, 220);
    public static final Color BACKGROUND = Color.rgb(135, 206, 235);
    public static final Color DARK_BLUE = Color.rgb(30, 60, 120);
    public static final Color LIGHT_BLUE = Color.rgb(100, 200, 255);
    public static final Color PINK = Color.rgb(255, 150, 200);
    public static final Color SCHOOL_YELLOW = Color.rgb(255, 220, 100);
    public static final Color SCHOOL_BROWN = Color.rgb(150, 100, 50);
    public static final Color GRAY = Color.rgb(100, 100, 100);
    public static final Color GLOW_COLOR = Color.rgb(255, 255, 150);
    
    private Stage primaryStage;
    private Canvas gameCanvas;
    private GraphicsContext gc;
    private ScoreSystem scoreSystem;
    private Player player;
    private List<Platform> platforms = new ArrayList<>();
    private List<FloatingText> floatingTexts = new ArrayList<>();
    private boolean gameOver = false;
    private boolean isBoy = true;
    
    // Управление
    private boolean moveLeft = false;
    private boolean moveRight = false;
    
    // Шрифты
    private Font fontLarge = new Font(48);
    private Font fontMedium = new Font(36);
    private Font fontSmall = new Font(24);
    
    @Override
    public void start(Stage primaryStage) {
        this.primaryStage = primaryStage;
        showStartScreen();
    }
    
    private void showStartScreen() {
        StackPane root = new StackPane();
        root.setStyle("-fx-background-color: linear-gradient(to bottom, #87CEEB, #6495ED);");
        
        // Фон школы
        drawSchoolBackground(root);
        
        // Контейнер для элементов
        VBox container = new VBox(20);
        container.setAlignment(Pos.TOP_CENTER);
        container.setPadding(new Insets(30, 0, 0, 0));
        
        // Заголовок
        Label title = new Label("DOODLE JUMP");
        title.setFont(fontLarge);
        title.setTextFill(RED);
        title.setStyle("-fx-font-weight: bold; -fx-effect: dropshadow(gaussian, black, 5, 0.5, 3, 3);");
        
        // Подзаголовок
        Label schoolLabel = new Label("ШКОЛА 258");
        schoolLabel.setFont(fontMedium);
        schoolLabel.setTextFill(WHITE);
        schoolLabel.setStyle("-fx-font-weight: bold; -fx-effect: dropshadow(gaussian, black, 3, 0.5, 2, 2);");
        
        // Контейнер для выбора персонажа
        HBox characterSelection = new HBox(30);
        characterSelection.setAlignment(Pos.CENTER);
        
        // Кнопка мальчика
        VBox boyBox = createCharacterBox(true, "УЧЕНИК");
        // Кнопка девочки
        VBox girlBox = createCharacterBox(false, "УЧЕНИЦА");
        
        characterSelection.getChildren().addAll(boyBox, girlBox);
        
        // Инструкция
        Label instruction = new Label("ВЫБЕРИТЕ ПЕРСОНАЖА");
        instruction.setFont(fontMedium);
        instruction.setTextFill(DARK_BLUE);
        
        // Кнопка начала игры
        Button startButton = new Button("НАЧАТЬ ИГРУ");
        startButton.setFont(fontMedium);
        startButton.setStyle("-fx-background-color: #32CD32; -fx-text-fill: white; -fx-font-weight: bold; " +
                "-fx-padding: 15 30; -fx-background-radius: 10; -fx-effect: dropshadow(gaussian, rgba(0,0,0,0.5), 10, 0, 0, 5);");
        startButton.setOnAction(e -> startGame(isBoy));
        
        // Управление
        VBox controlsBox = new VBox(10);
        controlsBox.setAlignment(Pos.CENTER);
        Label control1 = new Label("← → или A D - Движение");
        Label control2 = new Label("ПРОБЕЛ - Прыжок");
        Label control3 = new Label("ESC - Выход");
        control1.setFont(fontSmall);
        control2.setFont(fontSmall);
        control3.setFont(fontSmall);
        control1.setTextFill(DARK_BLUE);
        control2.setTextFill(DARK_BLUE);
        control3.setTextFill(DARK_BLUE);
        controlsBox.getChildren().addAll(control1, control2, control3);
        
        container.getChildren().addAll(title, schoolLabel, instruction, characterSelection, startButton, controlsBox);
        root.getChildren().add(container);
        
        Scene scene = new Scene(root, WIDTH, HEIGHT);
        scene.setOnKeyPressed(e -> {
            if (e.getCode() == KeyCode.LEFT) isBoy = true;
            else if (e.getCode() == KeyCode.RIGHT) isBoy = false;
            else if (e.getCode() == KeyCode.ENTER || e.getCode() == KeyCode.SPACE) {
                startGame(isBoy);
            } else if (e.getCode() == KeyCode.ESCAPE) {
                Platform.exit();
            }
        });
        
        primaryStage.setTitle("Doodle Jump - Школа 258");
        primaryStage.setScene(scene);
        primaryStage.show();
    }
    
    private VBox createCharacterBox(boolean isBoy, String labelText) {
        VBox box = new VBox(10);
        box.setAlignment(Pos.CENTER);
        
        // Рамка
        Rectangle frame = new Rectangle(150, 180);
        frame.setArcWidth(20);
        frame.setArcHeight(20);
        frame.setFill(LIGHT_BLUE);
        frame.setStroke(isBoy ? BLUE : PINK);
        frame.setStrokeWidth(isBoy ? 4 : 2);
        
        // Изображение персонажа (заглушка)
        Rectangle character = new Rectangle(120, 160);
        character.setArcWidth(15);
        character.setArcHeight(15);
        character.setFill(isBoy ? Color.rgb(100, 150, 255) : Color.rgb(255, 150, 200));
        
        // Подпись
        Label label = new Label(labelText);
        label.setFont(fontMedium);
        label.setTextFill(WHITE);
        
        box.getChildren().addAll(frame, character, label);
        
        // Обработчик клика
        box.setOnMouseClicked(e -> {
            this.isBoy = isBoy;
            // Обновляем рамки
            for (var child : ((HBox) box.getParent()).getChildren()) {
                VBox vbox = (VBox) child;
                Rectangle rect = (Rectangle) vbox.getChildren().get(0);
                if (vbox == box) {
                    rect.setStroke(isBoy ? BLUE : PINK);
                    rect.setStrokeWidth(4);
                } else {
                    rect.setStrokeWidth(2);
                }
            }
        });
        
        return box;
    }
    
    private void drawSchoolBackground(Pane root) {
        // Здание школы
        Rectangle building = new Rectangle(200, 120);
        building.setFill(SCHOOL_YELLOW);
        building.setStroke(SCHOOL_BROWN);
        building.setStrokeWidth(3);
        building.setX((WIDTH - 200) / 2);
        building.setY(100);
        
        // Крыша
        javafx.scene.shape.Polygon roof = new javafx.scene.shape.Polygon();
        roof.getPoints().addAll(
            (double) (WIDTH/2 - 110), 100.0,
            (double) (WIDTH/2 + 110), 100.0,
            (double) WIDTH/2, 70.0
        );
        roof.setFill(RED);
        roof.setStroke(BLACK);
        roof.setStrokeWidth(2);
        
        // Окно
        Rectangle window = new Rectangle(40, 30);
        window.setFill(LIGHT_BLUE);
        window.setStroke(BLACK);
        window.setStrokeWidth(2);
        window.setX(WIDTH/2 - 20);
        window.setY(130);
        
        // Дверь
        Rectangle door = new Rectangle(30, 60);
        door.setFill(SCHOOL_BROWN);
        door.setStroke(BLACK);
        door.setStrokeWidth(2);
        door.setX(WIDTH/2 + 50);
        door.setY(160);
        
        // Надпись "ШКОЛА 258"
        Label schoolText = new Label("ШКОЛА 258");
        schoolText.setFont(fontMedium);
        schoolText.setTextFill(WHITE);
        schoolText.setLayoutX(WIDTH/2 - 70);
        schoolText.setLayoutY(60);
        schoolText.setStyle("-fx-effect: dropshadow(gaussian, black, 3, 0.5, 2, 2);");
        
        root.getChildren().addAll(building, roof, window, door, schoolText);
    }
    
    private void startGame(boolean isBoy) {
        scoreSystem = new ScoreSystem();
        player = new Player(isBoy);
        platforms.clear();
        floatingTexts.clear();
        gameOver = false;
        
        generateInitialPlatforms();
        
        // Создаем игровой интерфейс
        BorderPane gameRoot = new BorderPane();
        gameRoot.setStyle("-fx-background-color: #87CEEB;");
        
        gameCanvas = new Canvas(WIDTH, HEIGHT);
        gc = gameCanvas.getGraphicsContext2D();
        
        gameRoot.setCenter(gameCanvas);
        
        // HUD для отображения счета
        HBox hud = new HBox(20);
        hud.setPadding(new Insets(10));
        hud.setAlignment(Pos.TOP_LEFT);
        
        Label scoreLabel = new Label("Очки: 0");
        scoreLabel.setFont(fontMedium);
        scoreLabel.setTextFill(YELLOW);
        scoreLabel.setStyle("-fx-effect: dropshadow(gaussian, black, 3, 0.5, 2, 2);");
        
        Label highScoreLabel = new Label("Рекорд: 0");
        highScoreLabel.setFont(fontMedium);
        highScoreLabel.setTextFill(YELLOW);
        highScoreLabel.setStyle("-fx-effect: dropshadow(gaussian, black, 3, 0.5, 2, 2);");
        
        hud.getChildren().addAll(scoreLabel, highScoreLabel);
        gameRoot.setTop(hud);
        
        Scene gameScene = new Scene(gameRoot, WIDTH, HEIGHT);
        
        // Обработка ввода
        gameScene.setOnKeyPressed(e -> {
            if (e.getCode() == KeyCode.LEFT || e.getCode() == KeyCode.A) {
                moveLeft = true;
            } else if (e.getCode() == KeyCode.RIGHT || e.getCode() == KeyCode.D) {
                moveRight = true;
            } else if (e.getCode() == KeyCode.SPACE && !gameOver) {
                player.jump();
            } else if (e.getCode() == KeyCode.R && gameOver) {
                restartGame();
            } else if (e.getCode() == KeyCode.ESCAPE) {
                scoreSystem.saveHighScore();
                Platform.exit();
            }
        });
        
        gameScene.setOnKeyReleased(e -> {
            if (e.getCode() == KeyCode.LEFT || e.getCode() == KeyCode.A) {
                moveLeft = false;
            } else if (e.getCode() == KeyCode.RIGHT || e.getCode() == KeyCode.D) {
                moveRight = false;
            }
        });
        
        primaryStage.setScene(gameScene);
        
        // Запуск игрового цикла
        AnimationTimer gameLoop = new AnimationTimer() {
            private long lastUpdate = 0;
            
            @Override
            public void handle(long now) {
                if (lastUpdate == 0) {
                    lastUpdate = now;
                    return;
                }
                
                double deltaTime = (now - lastUpdate) / 1_000_000_000.0; // в секундах
                if (deltaTime < 1.0 / FPS) return;
                
                update(deltaTime);
                draw();
                
                // Обновляем HUD
                scoreLabel.setText("Очки: " + scoreSystem.getScore());
                highScoreLabel.setText("Рекорд: " + scoreSystem.getHighScore());
                
                lastUpdate = now;
            }
        };
        
        gameLoop.start();
    }
    
    private void update(double deltaTime) {
        if (gameOver) return;
        
        scoreSystem.update();
        
        // Управление
        if (moveLeft) player.move(-1);
        if (moveRight) player.move(1);
        
        // Обновление игрока
        Player.UpdateResult result = player.update(platforms, scoreSystem);
        
        if (result == null) {
            gameOver();
            return;
        }
        
        if (result.points > 0) {
            floatingTexts.add(new FloatingText(
                "+" + result.points,
                result.x, result.y - 20,
                YELLOW, 24
            ));
            
            if (scoreSystem.getCombo() >= 3) {
                floatingTexts.add(new FloatingText(
                    "КОМБО x" + scoreSystem.getCombo() + "!",
                    result.x, result.y - 40,
                    ORANGE, 24
                ));
            }
            
            if (scoreSystem.getMultiplier() > 1.0) {
                floatingTexts.add(new FloatingText(
                    String.format("x%.1f", scoreSystem.getMultiplier()),
                    result.x, result.y - 60,
                    Color.rgb(255, 100, 255), 24
                ));
            }
        }
        
        // Прокрутка мира
        if (player.getY() < SCROLL_THRESHOLD && player.getVelocityY() < 0) {
            double scrollAmount = SCROLL_THRESHOLD - player.getY();
            
            if (scrollAmount >= MIN_HEIGHT_FOR_SCORE) {
                int heightBonus = scoreSystem.addHeightBonus((int) scrollAmount);
                if (heightBonus > 0) {
                    floatingTexts.add(new FloatingText(
                        "+" + heightBonus,
                        player.getX() + PLAYER_WIDTH / 2,
                        player.getY() - 30,
                        DARK_BLUE, 24
                    ));
                }
            }
            
            player.setY(player.getY() + scrollAmount);
            
            for (Platform platform : platforms) {
                platform.setY(platform.getY() + scrollAmount);
            }
        }
        
        // Обновление платформ
        platforms.removeIf(platform -> !platform.update());
        platforms.removeIf(platform -> platform.getY() > HEIGHT + 100);
        
        generateNewPlatforms();
        
        // Обновление плавающего текста
        floatingTexts.removeIf(text -> !text.update());
    }
    
    private void draw() {
        // Очистка canvas
        gc.clearRect(0, 0, WIDTH, HEIGHT);
        
        // Фон
        gc.setFill(BACKGROUND);
        gc.fillRect(0, 0, WIDTH, HEIGHT);
        
        // Облака
        drawClouds();
        
        // Платформы
        for (Platform platform : platforms) {
            platform.draw(gc);
        }
        
        // Игрок
        player.draw(gc);
        
        // Плавающий текст
        for (FloatingText text : floatingTexts) {
            text.draw(gc);
        }
        
        // HUD
        drawHUD();
        
        // Экран окончания игры
        if (gameOver) {
            drawGameOverScreen();
        }
    }
    
    private void drawClouds() {
        gc.setFill(Color.rgb(255, 255, 255, 0.8));
        
        // Облако 1
        gc.fillOval(100, 100, 60, 40);
        gc.fillOval(140, 90, 50, 30);
        gc.fillOval(130, 120, 40, 25);
        
        // Облако 2
        gc.fillOval(350, 150, 50, 30);
        gc.fillOval(380, 140, 60, 35);
        gc.fillOval(370, 170, 40, 25);
    }
    
    private void drawHUD() {
        gc.setFill(YELLOW);
        gc.setFont(new Font(20));
        gc.setTextAlign(javafx.scene.text.TextAlignment.LEFT);
        gc.fillText("Очки: " + scoreSystem.getScore(), 10, 30);
        
        gc.setFill(YELLOW);
        gc.fillText("Рекорд: " + scoreSystem.getHighScore(), WIDTH - 150, 30);
        
        if (scoreSystem.getCombo() > 0) {
            gc.setFill(ORANGE);
            gc.setFont(new Font(16));
            gc.fillText("Комбо: " + scoreSystem.getCombo(), 10, 60);
        }
        
        if (scoreSystem.getMultiplier() > 1.0) {
            gc.setFill(Color.rgb(255, 100, 255));
            gc.fillText(String.format("Множитель: x%.1f", scoreSystem.getMultiplier()), 10, 85);
        }
    }
    
    private void drawGameOverScreen() {
        gc.setFill(Color.rgb(0, 0, 0, 0.7));
        gc.fillRect(0, 0, WIDTH, HEIGHT);
        
        gc.setFill(RED);
        gc.setFont(new Font(48));
        gc.setTextAlign(javafx.scene.text.TextAlignment.CENTER);
        gc.fillText("GAME OVER", WIDTH / 2, HEIGHT / 2 - 50);
        
        gc.setFill(YELLOW);
        gc.setFont(new Font(36));
        gc.fillText("Очки: " + scoreSystem.getScore(), WIDTH / 2, HEIGHT / 2);
        gc.fillText("Рекорд: " + scoreSystem.getHighScore(), WIDTH / 2, HEIGHT / 2 + 40);
        
        gc.setFill(WHITE);
        gc.setFont(new Font(24));
        gc.fillText("Нажмите R для перезапуска", WIDTH / 2, HEIGHT / 2 + 100);
        gc.fillText("Нажмите ESC для выхода", WIDTH / 2, HEIGHT / 2 + 140);
    }
    
    private void gameOver() {
        gameOver = true;
        scoreSystem.saveHighScore();
    }
    
    private void restartGame() {
        scoreSystem.reset();
        player = new Player(isBoy);
        platforms.clear();
        floatingTexts.clear();
        gameOver = false;
        generateInitialPlatforms();
    }
    
    private void generateInitialPlatforms() {
        platforms.add(new Platform(
            WIDTH / 2 - PLATFORM_WIDTH / 2,
            HEIGHT - 100,
            "normal"
        ));
        
        double currentY = HEIGHT - 150;
        
        for (int i = 0; i < 19; i++) {
            double rand = Math.random();
            String platformType = "normal";
            
            if (rand < 0.1) platformType = "breaking";
            else if (rand < 0.2) platformType = "spring";
            else if (rand < 0.4) platformType = "moving";
            
            double minY = currentY - 80;
            double maxY = currentY - 40;
            
            PlatformPosition pos = findValidPlatformPosition(minY, maxY);
            
            platforms.add(new Platform(pos.x, pos.y, platformType));
            currentY = pos.y;
        }
    }
    
    private void generateNewPlatforms() {
        while (platforms.size() < 15) {
            double minY, maxY;
            
            if (!platforms.isEmpty()) {
                double highestY = platforms.stream()
                    .mapToDouble(Platform::getY)
                    .min()
                    .orElse(HEIGHT);
                minY = highestY - 120;
                maxY = highestY - 60;
            } else {
                minY = -150;
                maxY = -80;
            }
            
            double rand = Math.random();
            String platformType = "normal";
            
            if (rand < 0.15) platformType = "breaking";
            else if (rand < 0.3) platformType = "spring";
            else if (rand < 0.5) platformType = "moving";
            
            PlatformPosition pos = findValidPlatformPosition(minY, maxY);
            platforms.add(new Platform(pos.x, pos.y, platformType));
        }
    }
    
    private PlatformPosition findValidPlatformPosition(double minY, double maxY) {
        for (int attempt = 0; attempt < 50; attempt++) {
            double x = Math.random() * (WIDTH - PLATFORM_WIDTH);
            double y = minY + Math.random() * (maxY - minY);
            
            if (isValidPosition(x, y)) {
                return new PlatformPosition(x, y);
            }
        }
        
        // Если не нашли подходящую позицию, возвращаем случайную
        return new PlatformPosition(
            Math.random() * (WIDTH - PLATFORM_WIDTH),
            minY + Math.random() * (maxY - minY)
        );
    }
    
    private boolean isValidPosition(double x, double y) {
        if (x < 0 || x + PLATFORM_WIDTH > WIDTH) return false;
        
        for (Platform platform : platforms) {
            double verticalDistance = Math.abs(y - platform.getY());
            if (verticalDistance < MIN_PLATFORM_DISTANCE) {
                if (!(x + PLATFORM_WIDTH < platform.getX() || x > platform.getX() + platform.getWidth())) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        launch(args);
    }
    
    // Вспомогательные классы
    
    private static class PlatformPosition {
        double x, y;
        
        PlatformPosition(double x, double y) {
            this.x = x;
            this.y = y;
        }
    }
}

// ==================== КЛАСС ScoreSystem ====================

class ScoreSystem {
    private int score = 0;
    private int highScore = 0;
    private int combo = 0;
    private int maxCombo = 0;
    private double multiplier = 1.0;
    private int multiplierTimer = 0;
    private double lastPlatformY = DoodleJump.HEIGHT - 100;
    
    public ScoreSystem() {
        loadHighScore();
    }
    
    private void loadHighScore() {
        try {
            LocalDate today = LocalDate.now();
            File file = new File("score_data.json");
            
            if (file.exists()) {
                String content = new String(Files.readAllBytes(file.toPath()));
                // Простая JSON-обработка
                if (content.contains("\"high_score\":")) {
                    String[] parts = content.split("\"high_score\":");
                    if (parts.length > 1) {
                        String scoreStr = parts[1].split(",")[0].trim();
                        highScore = Integer.parseInt(scoreStr);
                    }
                }
            }
        } catch (Exception e) {
            System.out.println("Ошибка загрузки рекорда: " + e.getMessage());
            highScore = 0;
        }
    }
    
    public void saveHighScore() {
        try {
            String content = String.format(
                "{\"high_score\": %d, \"last_date\": \"%s\", \"last_updated\": \"%s\"}",
                highScore,
                LocalDate.now().toString(),
                java.time.LocalDateTime.now().toString()
            );
            Files.write(Paths.get("score_data.json"), content.getBytes());
        } catch (Exception e) {
            System.out.println("Ошибка сохранения рекорда: " + e.getMessage());
        }
    }
    
    public int addScore(int points, String reason) {
        int actualPoints = (int) (points * multiplier);
        score += actualPoints;
        
        if (score > highScore) {
            highScore = score;
        }
        
        return actualPoints;
    }
    
    public boolean addCombo(double platformY) {
        double heightDiff = Math.abs(lastPlatformY - platformY);
        
        if (heightDiff >= DoodleJump.MIN_HEIGHT_FOR_SCORE) {
            combo++;
            
            if (combo > maxCombo) {
                maxCombo = combo;
            }
            
            if (combo >= 5) {
                multiplier = Math.min(3.0, 1.0 + (combo - 4) * 0.2);
                multiplierTimer = 120;
            }
            
            lastPlatformY = platformY;
            return true;
        } else {
            resetCombo();
            return false;
        }
    }
    
    public void resetCombo() {
        combo = 0;
        multiplier = 1.0;
    }
    
    public void update() {
        if (multiplierTimer > 0) {
            multiplierTimer--;
            if (multiplierTimer == 0 && combo < 5) {
                multiplier = 1.0;
            }
        }
    }
    
    public int addPlatformHit(String platformType, double platformY) {
        if (!addCombo(platformY)) {
            return 0;
        }
        
        int points = 0;
        
        switch (platformType) {
            case "normal": points = 10; break;
            case "moving": points = 20; break;
            case "breaking": points = 30; break;
            case "spring": points = 15; break;
        }
        
        int comboBonus = combo * 2;
        points += comboBonus;
        
        return addScore(points, "платформа " + platformType);
    }
    
    public int addHeightBonus(int height) {
        if (height < DoodleJump.MIN_HEIGHT_FOR_SCORE) {
            return 0;
        }
        int points = height / 10;
        return addScore(points, "бонус за высоту");
    }
    
    public int addPerfectLanding() {
        return addScore(50, "идеальное приземление!");
    }
    
    public void reset() {
        score = 0;
        combo = 0;
        multiplier = 1.0;
        multiplierTimer = 0;
        lastPlatformY = DoodleJump.HEIGHT - 100;
    }
    
    // Геттеры
    public int getScore() { return score; }
    public int getHighScore() { return highScore; }
    public int getCombo() { return combo; }
    public int getMaxCombo() { return maxCombo; }
    public double getMultiplier() { return multiplier; }
}

// ==================== КЛАСС FloatingText ====================

class FloatingText {
    private String text;
    private double x, y;
    private Color color;
    private int size;
    private int duration;
    private int timer = 0;
    private double alpha = 1.0;
    
    public FloatingText(String text, double x, double y, Color color, int size) {
        this.text = text;
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = size;
        this.duration = 60;
    }
    
    public boolean update() {
        timer++;
        y -= 1;
        alpha = Math.max(0, 1.0 - (double) timer / duration);
        return timer < duration;
    }
    
    public void draw(GraphicsContext gc) {
        gc.setGlobalAlpha(alpha);
        gc.setFill(color);
        gc.setFont(new Font(size));
        gc.setTextAlign(javafx.scene.text.TextAlignment.CENTER);
        gc.fillText(text, x, y);
        gc.setGlobalAlpha(1.0);
    }
}

// ==================== КЛАСС Player ====================

class Player {
    private double x, y;
    private double velocityY = 0;
    private boolean jumping = false;
    private int direction = 1;
    private boolean isBoy;
    private Platform lastPlatform = null;
    private boolean justJumped = false;
    private int animationTimer = 0;
    private boolean walkAnimation = false;
    
    public Player(boolean isBoy) {
        this.x = DoodleJump.WIDTH / 2 - DoodleJump.PLAYER_WIDTH / 2;
        this.y = DoodleJump.HEIGHT - 200;
        this.isBoy = isBoy;
    }
    
    public static class UpdateResult {
        public final int points;
        public final double x, y;
        
        public UpdateResult(int points, double x, double y) {
            this.points = points;
            this.x = x;
            this.y = y;
        }
    }
    
    public UpdateResult update(List<Platform> platforms, ScoreSystem scoreSystem) {
        justJumped = false;
        velocityY += DoodleJump.GRAVITY;
        y += velocityY;
        
        animationTimer++;
        
        // Проверка столкновений с платформами
        for (Platform platform : platforms) {
            if (velocityY > 0) {
                if (y + DoodleJump.PLAYER_HEIGHT >= platform.getY() &&
                    y + DoodleJump.PLAYER_HEIGHT <= platform.getY() + 10 &&
                    x + DoodleJump.PLAYER_WIDTH > platform.getX() &&
                    x < platform.getX() + platform.getWidth()) {
                    
                    double playerCenter = x + DoodleJump.PLAYER_WIDTH / 2;
                    double platformCenter = platform.getX() + platform.getWidth() / 2;
                    double distance = Math.abs(playerCenter - platformCenter);
                    
                    int perfectBonus = 0;
                    if (distance < 10 && platform != lastPlatform) {
                        perfectBonus = scoreSystem.addPerfectLanding();
                    }
                    
                    int pointsAdded = platform.onLand(scoreSystem);
                    
                    if (platform.getType().equals("spring")) {
                        jump(DoodleJump.JUMP_FORCE * 1.5);
                    } else {
                        jump();
                    }
                    
                    justJumped = true;
                    lastPlatform = platform;
                    
                    int totalPoints = pointsAdded + perfectBonus;
                    return new UpdateResult(totalPoints, platform.getX() + platform.getWidth() / 2, platform.getY());
                }
            }
        }
        
        // Выход за границы экрана
        if (x > DoodleJump.WIDTH) {
            x = -DoodleJump.PLAYER_WIDTH;
        } else if (x + DoodleJump.PLAYER_WIDTH < 0) {
            x = DoodleJump.WIDTH;
        }
        
        // Падение
        if (y > DoodleJump.HEIGHT) {
            return null;
        }
        
        return new UpdateResult(0, 0, 0);
    }
    
    public void jump() {
        jump(DoodleJump.JUMP_FORCE);
    }
    
    public void jump(double force) {
        velocityY = -force;
        jumping = true;
    }
    
    public void move(int direction) {
        x += direction * 8;
        this.direction = direction;
        walkAnimation = true;
    }
    
    public void draw(GraphicsContext gc) {
        Color playerColor = isBoy ? DoodleJump.BLUE : DoodleJump.PINK;
        
        // Анимация прыжка
        if (jumping && velocityY < 0) {
            double scaleFactor = 1.0 + Math.abs(velocityY) * 0.01;
            double scaledWidth = DoodleJump.PLAYER_WIDTH * scaleFactor;
            double scaledHeight = DoodleJump.PLAYER_HEIGHT * scaleFactor;
            
            gc.setFill(playerColor);
            gc.fillRect(
                x - (scaledWidth - DoodleJump.PLAYER_WIDTH) / 2,
                y - (scaledHeight - DoodleJump.PLAYER_HEIGHT),
                scaledWidth,
                scaledHeight
            );
            
            gc.setStroke(DoodleJump.BLACK);
            gc.setLineWidth(2);
            gc.strokeRect(
                x - (scaledWidth - DoodleJump.PLAYER_WIDTH) / 2,
                y - (scaledHeight - DoodleJump.PLAYER_HEIGHT),
                scaledWidth,
                scaledHeight
            );
        }
        // Анимация ходьбы
        else if (walkAnimation && velocityY >= 0) {
            double bounce = Math.sin(animationTimer * 0.3) * 2;
            
            gc.setFill(playerColor);
            gc.fillRect(x, y + bounce, DoodleJump.PLAYER_WIDTH, DoodleJump.PLAYER_HEIGHT);
            
            gc.setStroke(DoodleJump.BLACK);
            gc.setLineWidth(2);
            gc.strokeRect(x, y + bounce, DoodleJump.PLAYER_WIDTH, DoodleJump.PLAYER_HEIGHT);
        }
        // Обычное состояние
        else {
            gc.setFill(playerColor);
            gc.fillRect(x, y, DoodleJump.PLAYER_WIDTH, DoodleJump.PLAYER_HEIGHT);
            
            gc.setStroke(DoodleJump.BLACK);
            gc.setLineWidth(2);
            gc.strokeRect(x, y, DoodleJump.PLAYER_WIDTH, DoodleJump.PLAYER_HEIGHT);
        }
        
        // Лицо
        gc.setFill(Color.rgb(255, 228, 196)); // Цвет кожи
        gc.fillOval(x + DoodleJump.PLAYER_WIDTH / 2 - 12, y + 8, 24, 24);
        gc.setStroke(DoodleJump.BLACK);
        gc.strokeOval(x + DoodleJump.PLAYER_WIDTH / 2 - 12, y + 8, 24, 24);
        
        // Глаза
        gc.setFill(DoodleJump.BLACK);
        double eyeOffset = direction > 0 ? -3 : 3;
        gc.fillOval(x + DoodleJump.PLAYER_WIDTH / 2 -
